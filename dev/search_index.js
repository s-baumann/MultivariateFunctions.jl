var documenterSearchIndex = {"docs":
[{"location":"#MultivariateFunctions","page":"MultivariateFunctions","title":"MultivariateFunctions","text":"This implements single algebra and evaluation on Multivariate functions. There are a few ways in which it can be used.\n\nThis can be used for approximation functions. It can currently implement OLS functions, chebyshev polynomials, the schumaker shape preserving spline and basic interpolation schemes. It can also implement Recursive Partitioning and create Multivariate Adaptive Regression (MARS) Splines. It could be extended to implement other approximation schemes.\nAs in the StochasticIntegrals.jl package this package can be used to define functions that will be the integrands in stochastic integrals. This has the benefit that the means, variances & covariances implied by these stochastic integrals can be found analytically.\nAll basic algebra and calculus on a MultivariateFunction can be done analytically.\nThe Newton's method is implemented so that roots and optima can be found using analytical Jacobians and Hessians.","category":"section"},{"location":"#Contents","page":"MultivariateFunctions","title":"Contents","text":"Depth = 2","category":"section"},{"location":"1_structs_and_limitations/#Structs","page":"Structs","title":"Structs","text":"There are four main MultivariateFunction structs that are part of this package. These are:\n\nPE_Function - This is the basic function type. It has a form of ae^b(x-base) (x-base)^d.\nSum_Of_Functions - This is an array of PE_Functions. Note that by adding PE_Functions we can replicate any given polynomial. Hence from Weierstrass' approximation theorem we can approximate any continuous function on a bounded domain to any desired level of accuracy (whether this is practical in numerical computing depends on the function being approximated).\nPiecewise_Function - This defines a different MultivariateFunction for each part of the x domain.\nSum_Of_Piecewise_Functions - Mathematically this does the same job as a Piecewise_Function but is dramatically more efficient when the contribution of different dimensions to the Piecewise_Function is additively separable.\n\nIt is possible to perform any additions, subtractions, multiplications between any two MultivariateFunctions and between Ints/Floats and any MultivariateFunction. No division is allowed and it is not possible to raise a MultivariateFunction to a negative power. This is to ensure that all Multivariatefunctions are analytically integrable and differentiable. This may change in future releases.","category":"section"},{"location":"1_structs_and_limitations/#Major-limitations","page":"Structs","title":"Major limitations","text":"It is not possible to divide by Multivariate functions or raise them by a negative power.\nWhen multiplying PE_Functions with different base dates there is often an issue of very high or very low numbers that go outside machine precision. If one were trying to change a PE_Function from base 2010 to 50, this would not generally be possible. This is because to change ae^x-2020 to qe^x- 50 we need to premultiply the first expression by e^-1950 which is often a tiny number. In these cases it is better to do the algebra on paper and rewriting the code accordingly as often base changes cancel out on paper. It is also good to change bases as rarely as possible. If different Multivariate functions use different bases then there is a need to base change when multiplying them which can result in errors. Note that if base changes are segment in the x domain by means of a piecewise function then they should never interact meaning it is ok to use different bases here.","category":"section"},{"location":"1_structs_and_limitations/#Date-Handling","page":"Structs","title":"Date Handling","text":"All base dates are immediately converted to floats and are not otherwise saved. Thus there is no difference between a PE_Function created with a base as a float and one created with the matching date. This is done to simplify the code. All date conversions is done by finding the year fractions between the date and the global base date of Date(2000,1,1). This particular global base date should not affect anything as long as it is consistent. It is relatively trivial to change it (in the date_conversions.jl file) and recompile however if desired.","category":"section"},{"location":"6_examples_approximation/#Examples-Approximation","page":"Examples - Approximation","title":"Examples - Approximation","text":"","category":"section"},{"location":"6_examples_approximation/#OLS-approximation","page":"Examples - Approximation","title":"OLS approximation","text":"If we have lots of data that we want to summarise with OLS\n\n# Generating example data\nusing Random\nusing Distributions\nusing DataStructures\nRandom.seed!(1)\nobs = 1000\nX = rand(obs)\ny = X .+ rand(Normal(),obs) .+ 7\n# And now making an approximation function\napproxFunction, reg = create_ols_approximation(y, X, 2)","category":"section"},{"location":"6_examples_approximation/#Numerical-Integration-with-Chebyshev-polynomials","page":"Examples - Approximation","title":"Numerical Integration with Chebyshev polynomials","text":"And if we want to approximate the sin function in the [2.3, 5.6] bound with 7 polynomial terms and 20 approximation nodes:\n\nchebyshevs = create_chebyshev_approximation(sin, 20, 7, OrderedDict{Symbol,Tuple{Float64,Float64}}(:default => (2.3, 5.6)))\n\nWe can integrate the above term in the normal way to achieve Gauss-Chebyshev quadrature:\n\nintegral(chebyshevs, 2.3, 5.6)","category":"section"},{"location":"6_examples_approximation/#Multivariate:-MARS-Spline-for-approximation","page":"Examples - Approximation","title":"Multivariate: MARS Spline for approximation","text":"First we will generate some example data.\n\nusing MultivariateFunctions\nusing Random\nusing DataFrames\nusing Distributions\nusing DataStructures\n\nRandom.seed!(1992)\nnObs = 1000\ndd = DataFrame()\ndd[!, :x] = rand( Normal(),nObs) + 0.1 .* rand( Normal(),nObs)\ndd[!, :z] = rand( Normal(),nObs) + 0.1 .* rand( Normal(),nObs)\ndd[!, :w] = (0.5 .* rand( Normal(),nObs)) .+ 0.7.*(dd[!, :z] .- dd[!, :x]) + 0.1 .* rand( Normal(),nObs)\ndd[!, :y] = (dd[!, :x] .*dd[!, :w] ) .* (dd[!, :z] .- dd[!, :w]) .+ dd[!, :x] + rand( Normal(),nObs)\ndd[7,:y] = 1.0\ny = :y\nx_variables = Set{Symbol}([:w, :x, :z])\n\nIt is important to note here that we have a set of symbols for x_variables. This is the set of columns in the dataframe that we will use to predict y - the dependent variable.\n\nWe can then create an approximation with recursive partitioning:\n\nnumber_of_divisions = 7\nrp_4, rp_reg_4 = create_recursive_partitioning(dd, y, x_variables, number_of_divisions; rel_tol = 1e-3)\n\nWe can also create a MARS approximation spline:\n\nrp_1, rp_reg_1 = create_mars_spline(dd, y, x_variables, number_of_divisions; rel_tol = 1e-3)\n\nNote that the rel_tol here is the tolerance in the optimisation step for hinges (or divisions in the recursive partitioning case). In most applied cases it generally doesn't matter much if there is a hinge at 1.0006 or at 1.0007 so in most settings this can be set higher than you would generally set the tolerance for a numerical optimiser. For this reason the default value is 1e-02.","category":"section"},{"location":"5_examples_interpolation/#Examples-Data-interpolation","page":"Examples - Data interpolation","title":"Examples - Data interpolation","text":"Suppose we have want to approximate some function with some sampled points. First to generate some points\n\nconst global_base_date = Date(2000,1,1)\nStartDate = Date(2018, 7, 21)\nx = Array{Date}(undef, 20)\nfor i in 1:20\n    x[i] = StartDate +Dates.Day(2* (i-1))\nend\nfunction ff(x::Date)\n    days_between = years_from_global_base(x)\n    return log(days_between) + sqrt(days_between)\nend\ny = ff.(x)\n\nNow we can generate a function that can be used to easily interpolate from the sampled points:\n\nfunc = create_quadratic_spline(x,y)\n\nAnd we can evaluate from this function and integrate it and differentiate it in the normal way:\n\nevaluate(func, Date(2020,1,1))\nevaluate.(Ref(func), [Date(2020,1,1), Date(2021,1,2)])\nevaluate(derivative(func), Date(2021,1,2))\nintegral(func, Date(2020,1,1), Date(2021,1,2))\n\nIf we had wanted to interpolate instead with a constant method(from left or from right) or by linearly interpolating then we could have just generated func with a different method: create_constant_interpolation_to_left, create_constant_interpolation_to_right or create_linear_interpolation.","category":"section"},{"location":"2_interpolation_methods/#Univariate-Interpolation-Methods","page":"Univariate Interpolation Methods","title":"Univariate Interpolation Methods","text":"So far this package support the following interpolation schemes for one dimensional interpolation:\n\nConstant interpolation from the left to the right. Such a Piecewise_Function spline can be constructed by the create_constant_interpolation_to_right method.\nConstant interpolation from the right to the left. Such a Piecewise_Function spline can be constructed by the create_constant_interpolation_to_left method.\nLinear interpolation. Such a Piecewise_Function spline can be constructed by the create_linear_interpolation method.\nSchumaker shape preserving spline - Such a Piecewise_Function spline can be constructed by the create_quadratic_spline method. See Judd (1998) for details on how this is done.\n\nNote that interpolation in higher dimensions is hard and no such methods are yet available in this package. There are some approximation schemes that might work in this case however as described in the next section.","category":"section"},{"location":"3_approximation_methods/#Supported-Approximation-Methods","page":"Supported Approximation Methods","title":"Supported Approximation Methods","text":"In addition the following approximation schemes are available, each of which can be used in any number of dimensions (subject to having enough computational power)\n\nOLS regression - Performs an OLS regression of the data and generates a Sum_Of_Functions containing the resultant approximation. This should work well in many dimensions.\nChebyshev polynomials - Creates a Sum_Of_Functions that uses Chebyshev polynomials to approximate a certain function. Unlike the other approximation schemes this does not take in an arbitrary collection of datapoints but rather takes in a function that it evaluates at certain points in a grid to make an approximation function. This might be useful if the original function is expensive (so you want a cheaper one). You might also want to numerically integrate a function by getting a Chebyshev approximation function that can be analytically integrated. See Judd (1998) for details on how this is done.\nMars regression spline - Creates a Sum_Of_Piecewise_Functions representing a MARS regression spline. See Friedman (1991) for an explanation of the spline.","category":"section"},{"location":"7_api_reference/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"7_api_reference/#Types","page":"API Reference","title":"Types","text":"","category":"section"},{"location":"7_api_reference/#Date-Handling","page":"API Reference","title":"Date Handling","text":"","category":"section"},{"location":"7_api_reference/#Evaluation-and-Inspection","page":"API Reference","title":"Evaluation and Inspection","text":"","category":"section"},{"location":"7_api_reference/#Algebra","page":"API Reference","title":"Algebra","text":"","category":"section"},{"location":"7_api_reference/#Calculus","page":"API Reference","title":"Calculus","text":"","category":"section"},{"location":"7_api_reference/#Interpolation","page":"API Reference","title":"Interpolation","text":"","category":"section"},{"location":"7_api_reference/#Approximation","page":"API Reference","title":"Approximation","text":"","category":"section"},{"location":"7_api_reference/#MultivariateFunctions.PE_Unit","page":"API Reference","title":"MultivariateFunctions.PE_Unit","text":"PE_Unit(b_::Float64, base_::Float64, d_::Int)\nPE_Unit(b_::Float64, base_::Date, d_::Int)\n\nThis creates a PEUnit which has a functional form of exp(b(x-base)) (x-base)^d. They cannot be used in any productive way by themselves but are needed to construct a PEFunction. An empty PEUnit (which might be used to create a constant PEFunction) can be created by PEUnit().\n\n\n\n\n\n","category":"type"},{"location":"7_api_reference/#MultivariateFunctions.PE_Function","page":"API Reference","title":"MultivariateFunctions.PE_Function","text":"PE_Function(multiplier_::Float64, units_::UnitMap)\n\nThis is the main constructor for a PE Function. The functional form of the function is the multiplier multiplied by all PE_Units.\n\nFor instance the PEFunction created by PEFunction(6.0, makeunitmap([:x, :y] .=> [PEUnit(1.0,1.0,1), PEUnit(0.0,2.0,4)])) has a functional form of 6 (x-1) exp(x-1) (y-2)^4\n\nThe following convenience functions create a PEFunction where there is only one variable (with a symbol :default).     PEFunction(multiplier::Float64,b::Float64, base::Float64, d::Int)     PEFunction(multiplier::Float64,b::Float64, base::Date, d::Int) The following convenience function creates a PEFunction where there are no variables and hence it is constant:     PE_Function(num::Float64 = 0.0)\n\n\n\n\n\n","category":"type"},{"location":"7_api_reference/#MultivariateFunctions.Sum_Of_Functions","page":"API Reference","title":"MultivariateFunctions.Sum_Of_Functions","text":"Sum_Of_Functions(functions)\n\nCreates a SumOfFunctions from an array of PEFunctions and/or SumOfFunctions. The constructors for this type go through each input SumOfFunctions and takes out the contained PEFunctions (so unecessary nesting doesnt occur where a SumOfFunctions could contain another SumOfFunctions). The constructors also aggregate PEFunctions where possible. For intance if two PEFunctions have the same PEUnits and differ in their multiplier these multipliers can be added. The constructors also remove zero multiplier PEFunctions.\n\n\n\n\n\n","category":"type"},{"location":"7_api_reference/#MultivariateFunctions.Piecewise_Function","page":"API Reference","title":"MultivariateFunctions.Piecewise_Function","text":"Piecewise_Function(functions_::Array{Union{Missing,Sum_Of_Functions}}, thresholds_::OrderedDict{Symbol,Array{Float64,1}})\n\nCreates a PiecewiseFunction from a multidimensional array of SumOfFunctions and an ordered dict of thresholds. The xth dimension in the thresholds dict corresponds to the xth dimension of the array of functions. A function can be lookuped up considering the thresholds and then selecting from the array. For instance if the first dimension is denoted :y and it's thresholds are [-4.0,0.0,3.4] and we query at a point with a :y coordinate of 2.7 then the function we look up will be from the file functions[2, ...] where ... represents the coordinates the the other dimensions. This is because 2.7 is greater than the second element of [-4.0,0.0,3.4] but less than the third. If this piecewise function were to be queried at a :y coordinate of -5.0 then a missing value will be returned. To specify piecewise functions on an unlimited domain the first element of the threshold can be set as -Inf. To set a limited domain on the upper end then add a Missing value to the functions_ array. Any other (ie interior) point can also be made undefined by putting a missing value into the functions_ array.\n\nNote that PiecewiseFunction works by assigning a SumOfFunctions to every region within the space defined by the thresholds dict. It is only possible to specify a region as a hypercube however. More complex regions are not possible.\n\nNote too that piecewise functions will scale poorly in high dimensions. If there are 10 dimensions and each has 4 elements in its threshold dict then the array for the piecewise function will have more than one million entries. In cases where there are no interactions between dimensions it is more efficient to use a SumOfPiecewiseFunctions object (which is basically an array of Piecewise Functions). For instance consider the following function: f(x,y,z) = max(x,5) + max(y,3) + max(z,3) We could code this as a piecewise function or as the sum of three piecewise functions. The three piecewise function implementation will contain fewer PEFunctions.\n\n\n\n\n\n","category":"type"},{"location":"7_api_reference/#MultivariateFunctions.Sum_Of_Piecewise_Functions","page":"API Reference","title":"MultivariateFunctions.Sum_Of_Piecewise_Functions","text":"Sum_Of_Piecewise_Functions(functions_::Array{Piecewise_Function,1}, global_funcs_::Sum_Of_Functions)\n\nAt the cost of being less flexible a SumOfPiecewise_Functions is more efficient than a PiecewiseFunction. Use this if trying to represent a piecewise function that can be decomposed into a sum of lower dimensional piecewise functions.\n\n\n\n\n\n","category":"type"},{"location":"7_api_reference/#MultivariateFunctions.years_from_global_base","page":"API Reference","title":"MultivariateFunctions.years_from_global_base","text":"years_between(a::Date, b::Date)\nyears_between(a::Dates.Day, b::Dates.Day)\n\nReturns the number of years that have elapsed since 1-Jan-2000. For the purposes of this calculation there are 365.2422 days in a year.\n\n\n\n\n\n","category":"function"},{"location":"7_api_reference/#MultivariateFunctions.years_between","page":"API Reference","title":"MultivariateFunctions.years_between","text":"years_between(until::Date, from::Date)\nyears_between(until::Dates.Day, from::Dates.Day)\n\nReturns the number of years between two dates. For the purposes of this calculation there are 365.2422 days in a year.\n\n\n\n\n\n","category":"function"},{"location":"7_api_reference/#MultivariateFunctions.period_length","page":"API Reference","title":"MultivariateFunctions.period_length","text":"Period length is designed to convert TimePeriod objects to a float in a consistent way to years_from_global_base\n\n\n\n\n\n","category":"function"},{"location":"7_api_reference/#SchumakerSpline.evaluate","page":"API Reference","title":"SchumakerSpline.evaluate","text":"evaluate(f::MultivariateFunction, coordinates::Dict{Symbol,Float64})\nevaluates a function at coordinates.\n\nFor univariate functions with a variable name of :default (such as those created by PE_Function's convenience functions)\nevaluation can take place with no dictionary:\nevaluate(f::MultivariateFunction, coordinate::Float64)\n\n\n\n\n\nevaluate(hess::Hessian, coordinates::Dict{Symbol,Float64})\n\nThis evaluates a Hessian object to create a Hermitian matrix representing the hessian at a point.\n\n\n\n\n\n","category":"function"},{"location":"7_api_reference/#MultivariateFunctions.underlying_dimensions","page":"API Reference","title":"MultivariateFunctions.underlying_dimensions","text":"underlying_dimensions(f::MultivariateFunction)\nReturns a set containing all of the variables upon which f depends.\n\n\n\n\n\n","category":"function"},{"location":"7_api_reference/#MultivariateFunctions.:≂","page":"API Reference","title":"MultivariateFunctions.:≂","text":"≂\n\nThis tests whether two structs are close after allowing for numerical tolerance.\n\n\n\n\n\n","category":"function"},{"location":"7_api_reference/#MultivariateFunctions.rebadge","page":"API Reference","title":"MultivariateFunctions.rebadge","text":"rebadge(f::PE_Function, mapping::Dict{Symbol,Symbol})\ncan be used to change the names of the variables in a MultivariateFunction.\n\n\n\n\n\n","category":"function"},{"location":"7_api_reference/#MultivariateFunctions.change_base","page":"API Reference","title":"MultivariateFunctions.change_base","text":"change_base(f::PE_Function, new_bases::BaseMap)\n\nThis function changes the bases in the PEUnits of a PEFunction. This is useful for getting two PEFunctions comformable for simpler multiplication. Often a base change means that an array of PEFunctions are needed to represent a function. So an Array{PE_Function,1} is returned.\n\n\n\n\n\n","category":"function"},{"location":"7_api_reference/#Base.:+","page":"API Reference","title":"Base.:+","text":"+(f::MultivariateFunction,number::Float64)    +(f::MultivariateFunction,number::Int)\n\nA Multivariate Function can be added to an scalar to from a new MultivariateFunction. This action promotes a    PEFunction to a SumOf_Functions. The type of all other MultivariateFunctions is unchanged.\n\n\n\n\n\n+(f1::MultivariateFunction, f2::MultivariateFunction)\nAny two multivariate Functions can be added to form a MultivariateFunction reflecting the sum.\n\n\n\n\n\n","category":"function"},{"location":"7_api_reference/#Base.:-","page":"API Reference","title":"Base.:-","text":"-(f::MultivariateFunction,number::Float64)    -(f::MultivariateFunction,number::Int)\n\nA scalar can be subtracted from a Multivariate Function. This action promotes a    PEFunction to a SumOf_Functions. The type of all other MultivariateFunctions is unchanged.\n\n\n\n\n\n-(f1::MultivariateFunction, f2::MultivariateFunction)\nAny MultivariateFunction can be subtracted from another to form a MultivariateFunction reflecting the difference.\n\n\n\n\n\n","category":"function"},{"location":"7_api_reference/#Base.:*","page":"API Reference","title":"Base.:*","text":"*(f::MultivariateFunction,number::Float64)    *(f::MultivariateFunction,number::Int)\n\nA Multivariate can be multiplied by a scalar. This does not change the type of any MultivariateFunction.\n\n\n\n\n\n*(f1::MultivariateFunction, f2::MultivariateFunction)\nAny two MultivariateFunctions can be multiplied to form a MultivariateFunction reflecting the product.\n\n\n\n\n\n","category":"function"},{"location":"7_api_reference/#Base.:/","page":"API Reference","title":"Base.:/","text":"/(f::MultivariateFunction,number::Float64)    /(f::MultivariateFunction,number::Int)\n\nA Multivariate can be divided by a scalar. This does not change the type of any MultivariateFunction.    Note that the opposite operation cannot be done. While f / 5 is permitted 5 / f is not supported by this package.    It is not possible to divide by a function.\n\n\n\n\n\n","category":"function"},{"location":"7_api_reference/#Base.:^","page":"API Reference","title":"Base.:^","text":"^(f::MultivariateFunction,number::Int)\n\nA Multivariate can be raised by a positive Integer power. This will generally promote a PEFunction to a SumOf_Functions.    Note that the opposite operation cannot be done. While f ^ 5 is permitted 5 ^ f is not supported by this package.    It is not possible to raise by the power of a function.\n\n\n\n\n\n","category":"function"},{"location":"7_api_reference/#MultivariateFunctions.derivative","page":"API Reference","title":"MultivariateFunctions.derivative","text":" derivative(f::MultivariateFunction, derivs::Dict{Symbol,Int})\n\nThis generates a function representing the derivative of function f. The derivative is that specified by the derivs dict. So if derivs is Dict{[:x,:y] .=> [1,2]} then there will be one derivative with respect to x and 2 with respect to y.\n\n\n\n\n\n","category":"function"},{"location":"7_api_reference/#MultivariateFunctions.all_derivatives","page":"API Reference","title":"MultivariateFunctions.all_derivatives","text":" all_derivatives(f::MultivariateFunction, degree::Int = 2, dimensions::Set{Symbol} = underlying_dimensions(f))\n\nThis generates a dict containing functions representing all of the deriviates of a function up to the order of degree.\n\n\n\n\n\n","category":"function"},{"location":"7_api_reference/#MultivariateFunctions.integral","page":"API Reference","title":"MultivariateFunctions.integral","text":" integral(f::PE_Function, limits::Dict{Symbol,Tuple{Union{Symbol,Float64},Union{Symbol,Float64}}})\n integral(f::Sum_Of_Functions, limits::Dict{Symbol,Tuple{Union{Symbol,Float64},Union{Symbol,Float64}}})\n\nThis gives a function representing the integral of a function, f, with limits in each dimension given by a dict. The dict should contain a tuple for each variable in the function. The left member of the tuple contains the lower limit and the right member the upper limite. Each can be a Float64 or a symbol. If a symbol is input then this will get incorporated as a dimension in the MultivariateFunction created by the integral function.\n\n\n\n\n\n","category":"function"},{"location":"7_api_reference/#MultivariateFunctions.Hessian","page":"API Reference","title":"MultivariateFunctions.Hessian","text":"Hessian(f::MultivariateFunction, dimensions::Array{Symbol,1})\nHessian(derivs::Union{Dict{Dict{Symbol,Int},PE_Function},Dict{Dict{Symbol,Int},Sum_Of_Functions},Dict{Dict{Symbol,Int},Piecewise_Function}}, labels_::Array{Symbol,1})\n\nThis represents expressions for constructing a hessian matrix for a function. It can be evaluated to get a Hermitian matrix of the hessian at a particular location.\n\n\n\n\n\n","category":"type"},{"location":"7_api_reference/#MultivariateFunctions.jacobian","page":"API Reference","title":"MultivariateFunctions.jacobian","text":"jacobian(derivs::Union{Dict{Dict{Symbol,Int},PE_Function},Dict{Dict{Symbol,Int},Sum_Of_Functions},Dict{Dict{Symbol,Int},Piecewise_Function}}, labels::Array{Symbol,1})\njacobian(f::MultivariateFunction, dimensions::Array{Symbol,1})\n\nThis generates an array of MultivariateFunctions representing the derivatives of a function. This array can be evaluated with evaluate.(jacobian, Ref(coordinates))  to give a vector of the derivative values at a point.\n\n\n\n\n\n","category":"function"},{"location":"7_api_reference/#MultivariateFunctions.uniroot","page":"API Reference","title":"MultivariateFunctions.uniroot","text":"uniroot(f::MultivariateFunction, initial_guess::Dict{Symbol,Float64}; step_size::Float64 = 1.0, max_iters::Int = 40, convergence_tol::Float64 = 1e-10, print_reports::Bool = false)\n\nThis takes the analytical jacobian and hessian of a function and uses them to find a nearby root. It finds a root using Newton's method.\n\n\n\n\n\n","category":"function"},{"location":"7_api_reference/#MultivariateFunctions.find_local_optima","page":"API Reference","title":"MultivariateFunctions.find_local_optima","text":"find_local_optima(func::MultivariateFunction, initial_guess::Dict{Symbol,Float64}; step_size::Float64 = 1.0, max_iters::Int = 40, convergence_tol::Float64 = 1e-10, print_reports::Bool = false)\n\nThis takes the analytical jacobian and hessian of a function and uses them to find a nearby optima. The optima it will find are based on Newton's method. There is no way to specify whether a minimum or a maximum is sought in Newton's method (at least the pure version of it) and thus this function cannot selectively search for a maximum or minimum. It simply searches for a stationary point.\n\n\n\n\n\n","category":"function"},{"location":"7_api_reference/#MultivariateFunctions.hypercubes_to_integrate","page":"API Reference","title":"MultivariateFunctions.hypercubes_to_integrate","text":" integral(f::Piecewise_Function, limits::Dict{Symbol,Tuple{Float64,Float64}})\n integral(f::Sum_Of_Piecewise_Functions, limits::Dict{Symbol,Tuple{Float64,Float64}})\n\nThis gives a function representing the integral of a function, f, with limits in each dimension given by a dict. The dict should contain a tuple for each variable in the function. The left member of the tuple contains the lower limit and the right member the upper limite. Each must be a Float64 (Support for inputting a symbol is planned but not yet implemented).\n\n\n\n\n\n","category":"function"},{"location":"7_api_reference/#MultivariateFunctions.create_quadratic_spline","page":"API Reference","title":"MultivariateFunctions.create_quadratic_spline","text":"create_quadratic_spline(x::Array{Date,1},y::Array{Float64,1} ; gradients::Union{missing,Array{Float64,1}} = missing, extrapolation::Tuple{Schumaker_ExtrapolationSchemes,Schumaker_ExtrapolationSchemes} = (Curve, Curve), left_gradient::Union{Missing,Float64} = missing, right_gradient::Union{Missing,Float64} = missing, dim_name::Symbol = default_symbol)\ncreate_quadratic_spline(x::Array{Int,1},y::Array{Float64,1} ; gradients::Union{missing,Array{Float64,1}} = missing, extrapolation::Tuple{Schumaker_ExtrapolationSchemes,Schumaker_ExtrapolationSchemes} = (Curve, Curve), left_gradient::Union{Missing,Float64} = missing, right_gradient::Union{Missing,Float64} = missing, dim_name::Symbol = default_symbol)\ncreate_quadratic_spline(x::Array{Float64,1},y::Array{Float64,1} ; gradients::Union{missing,Array{Float64,1}} = missing, extrapolation::Tuple{Schumaker_ExtrapolationSchemes,Schumaker_ExtrapolationSchemes} = (Curve, Curve), left_gradient::Union{Missing,Float64} = missing, right_gradient::Union{Missing,Float64} = missing, dim_name::Symbol = default_symbol)\ncreate_quadratic_spline(schum::Schumaker; dim_name::Symbol = default_symbol)\n\nCreate a quadratic spline. The spline is a Schumaker shape-preserving spline which is taken from the SchumakerSpline.jl package.\n\n\n\n\n\n","category":"function"},{"location":"7_api_reference/#MultivariateFunctions.create_linear_interpolation","page":"API Reference","title":"MultivariateFunctions.create_linear_interpolation","text":"create_linear_interpolation(x::Array{Date,1},y::Array{Float64,1}; dim_name::Symbol = default_symbol)\ncreate_linear_interpolation(x::Array{<:DatePeriod,1},y::Array{Float64,1}; dim_name::Symbol = default_symbol)\ncreate_linear_interpolation(x::Array{Float64,1},y::Array{Float64,1}; dim_name::Symbol = default_symbol)\n\nCreate a piecewise linear one-dimensional function which interpolates linearly between datapoints.\n\n\n\n\n\n","category":"function"},{"location":"7_api_reference/#MultivariateFunctions.create_constant_interpolation_to_left","page":"API Reference","title":"MultivariateFunctions.create_constant_interpolation_to_left","text":"create_constant_interpolation_to_left(x::Array{Date,1},y::Array{Float64,1}; dim_name::Symbol = default_symbol)\ncreate_constant_interpolation_to_left(x::Array{<:DatePeriod,1},y::Array{Float64,1}; dim_name::Symbol = default_symbol)\ncreate_constant_interpolation_to_left(x::Array{Float64,1},y::Array{Float64,1}; dim_name::Symbol = default_symbol)\n\nCreate a piecewise constant one-dimensional function which carries values from the right to the left.\n\n\n\n\n\n","category":"function"},{"location":"7_api_reference/#MultivariateFunctions.create_constant_interpolation_to_right","page":"API Reference","title":"MultivariateFunctions.create_constant_interpolation_to_right","text":"create_constant_interpolation_to_right(x::Array{Date,1},y::Array{Float64,1}; dim_name::Symbol = default_symbol)\ncreate_constant_interpolation_to_right(x::Array{<:DatePeriod,1},y::Array{Float64,1}; dim_name::Symbol = default_symbol)\ncreate_constant_interpolation_to_right(x::Array{Float64,1},y::Array{Float64,1}; dim_name::Symbol = default_symbol)\n\nCreate a piecewise constant one-dimensional function which carries values from the left to the right.\n\n\n\n\n\n","category":"function"},{"location":"7_api_reference/#MultivariateFunctions.get_chebyshevs_up_to","page":"API Reference","title":"MultivariateFunctions.get_chebyshevs_up_to","text":"get_chebyshevs_up_to(num::Int, first_kind::Bool = true; dim_name::Symbol = default_symbol)\nget_chevyshevs_up_to(num::Int, first_kind::Bool = true; dim_name::Symbol = default_symbol)\nOutput all chebyshev polynomials up to degree num.\n\n\n\n\n\n","category":"function"},{"location":"7_api_reference/#MultivariateFunctions.create_chebyshev_approximation","page":"API Reference","title":"MultivariateFunctions.create_chebyshev_approximation","text":"create_chebyshev_approximation(f::Function, nodes::Int, degree::Int, limits::OrderedDict{Symbol,Tuple{Float64,Float64}}, function_takes_Dict::Bool = false)\n\nCreates a SumOfFunctions that approximates a function, f, with a set of chebyshevs of a particular degree. The nodes input specifies at how many locations the function is to be evaluated for approximation purposes in each dimension. The limits OrderedDict specifies the domain of where the function is to be approximated.\n\nIf functiontakesDict is true then the function will be evaluated by inputting a  Dict{Symbol,Float64}. Otherwise the function will be evaluated with f(values(limits)...) Note that the order of the OrderedDict specifies the order of inputs to the function in this case.\n\n\n\n\n\n","category":"function"},{"location":"7_api_reference/#MultivariateFunctions.create_ols_approximation","page":"API Reference","title":"MultivariateFunctions.create_ols_approximation","text":"create_ols_approximation(dd::DataFrame, y::Symbol, model::MultivariateFunction; dropcollinear = true)\ncreate_ols_approximation(dd::DataFrame, y::Symbol, model::Sum_Of_Functions; dropcollinear = true)\ncreate_ols_approximation(dd::DataFrame, y::Symbol, model::Sum_Of_Piecewise_Functions; dropcollinear = true)\n\nThis creates MultivariationFunction from an OLS regression predicting some variable. You input a dataframe and specify what column in that dataframe is to be predicted by inputting a symbol y. You also input the regression model. This is input as a Array{MultivariateFunction,1}. Each function that is input will be multiplied by the ols coefficient and will return a new function with these coefficients incorporated.\n\n\n\n\n\ncreate_ols_approximation(y::Array{Float64,1}, x::Array{Float64,1}, degree::Int; intercept::Bool = true, dim_name::Symbol = default_symbol, base_x::Float64 = 0.0)\ncreate_ols_approximation(y::Array{Float64,1}, x::Array{Date,1}, degree::Int; intercept::Bool = true, dim_name::Symbol = default_symbol, base_date::Date = global_base_date)\n\nThis predicts a linear relationship between the y and x arrays and creates a MultivariateFunction containing the approximation function. The degree specifies how many higher order terms of x should be used (for instance degree 2 implies x and x^2 are both used to predict y).\n\n\n\n\n\n","category":"function"},{"location":"7_api_reference/#MultivariateFunctions.create_saturated_ols_approximation","page":"API Reference","title":"MultivariateFunctions.create_saturated_ols_approximation","text":"create_saturated_ols_approximation(dd::DataFrame, y::Symbol, x_variables::Array{Symbol,1}, degree::Int; intercept::Bool = true,  bases::Dict{Symbol,Float64} = Dict{Symbol,Float64}(x_variables .=> repeat([0.0],length(x_variables))))\n\nThis creates MultivariateFunction from an OLS regression predicting some variable. You input a dataframe and specify what column in that dataframe is to be predicted by inputting a symbol y. you also put in an array of what x_variables should be used in prediction. A saturated ols model is then calculated up to the specified degree which is returned as a MultivariateFunction.\n\n\n\n\n\n","category":"function"},{"location":"7_api_reference/#MultivariateFunctions.create_mars_spline","page":"API Reference","title":"MultivariateFunctions.create_mars_spline","text":"create_mars_spline(dd::DataFrame, y::Symbol, x_variables::Set{Symbol}, MaxM::Int; rel_tol::Float64 = 1e-2)\n\nThis creates a mars spline given a dataframe, response variable and a set of xvariables from the dataframe. The relative tolerance is used in a one-dimensional optimisation step to determine what points at which split values to place a max(0,x-split) function in a particular dimension. The default is intentionally set high because precision is generally not the not that important. For small scale data however you might want to decrease it and increase it for large scale data. You might also want to decrease it if spline creation time doesnt matter much. Note that a small reltol only affects creation time for the spline and not the evaluation time.\n\n\n\n\n\n","category":"function"},{"location":"7_api_reference/#MultivariateFunctions.create_recursive_partitioning","page":"API Reference","title":"MultivariateFunctions.create_recursive_partitioning","text":"create_recursive_partitioning(dd::DataFrame, y::Symbol, x_variables::Set{Symbol}, MaxM::Int; rel_tol::Float64 = 1e-10)\n\nThis creates a recusive partitioning approximation. This seperates the space in to a series of hypercubes each of which has a constant value within the hypercube. Each step of the algorithm divides a hypercube along some dimension so that the different parts of the hypercube can recieve a different value. The relative tolerance is used in a one-dimensional optimisation step to determine what points at which split values to place a hypercube in a particular dimension. The default is intentionally set high because it generally doesnt matter that much. For small scale data however you might want to decrease it and increase it for large scale data. You might also want to decrease it if spline creation time doesnt matter much. Note that a small rel_tol only affects creation time for the spline and not the evaluation time.\n\n\n\n\n\n","category":"function"},{"location":"7_api_reference/#MultivariateFunctions.trim_mars_spline","page":"API Reference","title":"MultivariateFunctions.trim_mars_spline","text":"trimmarsspline(dd::DataFrame, y::Symbol, model::SumOfPiecewiseFunctions;                    maximumRSS::Float64 = -1.0, maximumincreaseinRSS::Float64 = -1.0, finalnumberoffunctions::Int = -1)\n\nThis trims a mars spline created in the createmarsspline function. This algorithm goes through each piecewise function in the mars spline and deletes the one that contributes least to the fit. A termination criterion must be set. There are three possible termination criterions. The first is the maximumRSS that can be tolerated. If this is set then functions will be deleted until the deletion of an additional function would push RSS over this amount. The second is maximumincreaseinRSS which will delete functions until a deletion increases RSS by more than this amount. The final is finalnumberof_functions which reduces the number of fucntions to this number.\n\n\n\n\n\n","category":"function"},{"location":"4_examples_algebra/#Examples-Algebra","page":"Examples - Algebra","title":"Examples - Algebra","text":"","category":"section"},{"location":"4_examples_algebra/#Univariate:-Basic-algebra","page":"Examples - Algebra","title":"Univariate: Basic algebra","text":"Consider we have a two functions f and g and want to add them, multiply them by some other function h, then square it and finally integrate the result between 2.0 and 2.8. This can be done analytically with MultivariateFunctions:\n\nf = PE_Function(1.0, 2.0, 4.0, 5)\ng = PE_Function(1.3, 2.0, 4.3, 2)\nh = PE_Function(5.0, 2.2, 1.0,0)\nresult_of_operations = (h*(f+g))^2\nintegral(result_of_operations, 2.0, 2.8)","category":"section"},{"location":"4_examples_algebra/#Multivariate:-Basic-algebra","page":"Examples - Algebra","title":"Multivariate: Basic algebra","text":"Consider we have a three functions f(x) = x^2 - 8 and g(y) = e^y and want to add them, multiply them by some other function h(xy) = 4 x e^y, then square it and finally integrate the result between 2.0 and 2.8 in the x domain and 2 and 3 in the y domain. This can be done analytically with MultivariateFunctions.\n\nThe additional complication from the univariate case here is that we need to define the names of the dimensions as we have more than one dimension.\n\nf = PE_Function(1.0, Dict(:x => PE_Unit(0.0,0.0,2))) - 8\ng = PE_Function(1.0, Dict(:y => PE_Unit(1.0,0.0,0)))\nh = PE_Function(4.0, Dict([:x, :y] .=> [PE_Unit(0.0,0.0,1), PE_Unit(1.0,0.0,0)]))\nresult_of_operations = (h*(f+g))^2\nintegration_limits = Dict([:x, :y] .=> [(2.0,2.8), (2.0,3.0)])\nintegral(result_of_operations, integration_limits)","category":"section"},{"location":"99_refs/#References","page":"References","title":"References","text":"Friedman, Jerome (1991) Multivariate Adaptive Regression Splines. The annals of Statistics 19(1). pp. 1-141.\n\nJudd, Kenneth (1998) Numerical Methods in Economics. 9780262100717. MIT Press.","category":"section"}]
}
