<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · MultivariateFunctions</title><meta name="title" content="API Reference · MultivariateFunctions"/><meta property="og:title" content="API Reference · MultivariateFunctions"/><meta property="twitter:title" content="API Reference · MultivariateFunctions"/><meta name="description" content="Documentation for MultivariateFunctions."/><meta property="og:description" content="Documentation for MultivariateFunctions."/><meta property="twitter:description" content="Documentation for MultivariateFunctions."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MultivariateFunctions</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">MultivariateFunctions</a></li><li><a class="tocitem" href="../1_structs_and_limitations/">Structs</a></li><li><a class="tocitem" href="../2_interpolation_methods/">Univariate Interpolation Methods</a></li><li><a class="tocitem" href="../3_approximation_methods/">Supported Approximation Methods</a></li><li><a class="tocitem" href="../4_examples_algebra/">Examples - Algebra</a></li><li><a class="tocitem" href="../5_examples_interpolation/">Examples - Data interpolation</a></li><li><a class="tocitem" href="../6_examples_approximation/">Examples - Approximation</a></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Date-Handling"><span>Date Handling</span></a></li><li><a class="tocitem" href="#Evaluation-and-Inspection"><span>Evaluation and Inspection</span></a></li><li><a class="tocitem" href="#Algebra"><span>Algebra</span></a></li><li><a class="tocitem" href="#Calculus"><span>Calculus</span></a></li><li><a class="tocitem" href="#Interpolation"><span>Interpolation</span></a></li><li><a class="tocitem" href="#Approximation"><span>Approximation</span></a></li></ul></li><li><a class="tocitem" href="../99_refs/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/s-baumann/MultivariateFunctions.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/s-baumann/MultivariateFunctions.jl/blob/master/docs/src/7_api_reference.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MultivariateFunctions.PE_Unit"><a class="docstring-binding" href="#MultivariateFunctions.PE_Unit"><code>MultivariateFunctions.PE_Unit</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PE_Unit(b_::Float64, base_::Float64, d_::Int)
PE_Unit(b_::Float64, base_::Date, d_::Int)</code></pre><p>This creates a PE<em>Unit which has a functional form of exp(b</em>(x-base<em>)) (x-base</em>)^d. They cannot be used in any productive way by themselves but are needed to construct a PE<em>Function. An empty PE</em>Unit (which might be used to create a constant PE<em>Function) can be created by PE</em>Unit().</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/MultivariateFunctions.jl/blob/439c52f985951594f07d67026f0f3a2cc6c4c5f2/src/0_structs_and_generic_reversals.jl#L6-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MultivariateFunctions.PE_Function"><a class="docstring-binding" href="#MultivariateFunctions.PE_Function"><code>MultivariateFunctions.PE_Function</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PE_Function(multiplier_::Float64, functions_::Dict{Symbol,PE_Unit})</code></pre><p>This is the main constructor for a PE Function. The functional form of the function is the multiplier multiplied by all PE_Units.</p><p>For instance the PE<em>Function created by PE</em>Function(6.0, Dict([:x, :y] .=&gt; [PE<em>Unit(1.0,1.0,1), PE</em>Unit(0.0,2.0,4)])) has a functional form of 6 (x-1) exp(x-1) (y-2)^4</p><p>The following convenience functions create a PE<em>Function where there is only one variable (with a symbol :default).     PE</em>Function(multiplier<em>::Float64,b</em>::Float64, base<em>::Float64, d</em>::Int)     PE<em>Function(multiplier</em>::Float64,b<em>::Float64, base</em>::Date, d<em>::Int) The following convenience function creates a PE</em>Function where there are no variables and hence it is constant:     PE_Function(num::Float64 = 0.0)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/MultivariateFunctions.jl/blob/439c52f985951594f07d67026f0f3a2cc6c4c5f2/src/0_structs_and_generic_reversals.jl#L46-L59">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MultivariateFunctions.Sum_Of_Functions"><a class="docstring-binding" href="#MultivariateFunctions.Sum_Of_Functions"><code>MultivariateFunctions.Sum_Of_Functions</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Sum_Of_Functions(functions)</code></pre><p>Creates a Sum<em>Of</em>Functions from an array of PE<em>Functions and/or Sum</em>Of<em>Functions. The constructors for this type go through each input Sum</em>Of<em>Functions and takes out the contained PE</em>Functions (so unecessary nesting doesnt occur where a Sum<em>Of</em>Functions could contain another Sum<em>Of</em>Functions). The constructors also aggregate PE<em>Functions where possible. For intance if two PE</em>Functions have the same PE<em>Units and differ in their multiplier these multipliers can be added. The constructors also remove zero multiplier PE</em>Functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/MultivariateFunctions.jl/blob/439c52f985951594f07d67026f0f3a2cc6c4c5f2/src/0_structs_and_generic_reversals.jl#L175-L182">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MultivariateFunctions.Piecewise_Function"><a class="docstring-binding" href="#MultivariateFunctions.Piecewise_Function"><code>MultivariateFunctions.Piecewise_Function</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Piecewise_Function(functions_::Array{Union{Missing,Sum_Of_Functions}}, thresholds_::OrderedDict{Symbol,Array{Float64,1}})</code></pre><p>Creates a Piecewise<em>Function from a multidimensional array of Sum</em>Of<em>Functions and an ordered dict of thresholds. The xth dimension in the thresholds dict corresponds to the xth dimension of the array of functions. A function can be lookuped up considering the thresholds and then selecting from the array. For instance if the first dimension is denoted :y and it&#39;s thresholds are [-4.0,0.0,3.4] and we query at a point with a :y coordinate of 2.7 then the function we look up will be from the file functions</em>[2, ...] where ... represents the coordinates the the other dimensions. This is because 2.7 is greater than the second element of [-4.0,0.0,3.4] but less than the third. If this piecewise function were to be queried at a :y coordinate of -5.0 then a missing value will be returned. To specify piecewise functions on an unlimited domain the first element of the threshold can be set as -Inf. To set a limited domain on the upper end then add a Missing value to the functions_ array. Any other (ie interior) point can also be made undefined by putting a missing value into the functions_ array.</p><p>Note that Piecewise<em>Function works by assigning a Sum</em>Of<em>Functions to every region within the space defined by the thresholds</em> dict. It is only possible to specify a region as a hypercube however. More complex regions are not possible.</p><p>Note too that piecewise functions will scale poorly in high dimensions. If there are 10 dimensions and each has 4 elements in its threshold dict then the array for the piecewise function will have more than one million entries. In cases where there are no interactions between dimensions it is more efficient to use a Sum<em>Of</em>Piecewise<em>Functions object (which is basically an array of Piecewise Functions). For instance consider the following function: f(x,y,z) = max(x,5) + max(y,3) + max(z,3) We could code this as a piecewise function or as the sum of three piecewise functions. The three piecewise function implementation will contain fewer PE</em>Functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/MultivariateFunctions.jl/blob/439c52f985951594f07d67026f0f3a2cc6c4c5f2/src/0_structs_and_generic_reversals.jl#L295-L315">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MultivariateFunctions.Sum_Of_Piecewise_Functions"><a class="docstring-binding" href="#MultivariateFunctions.Sum_Of_Piecewise_Functions"><code>MultivariateFunctions.Sum_Of_Piecewise_Functions</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Sum_Of_Piecewise_Functions(functions_::Array{Piecewise_Function,1}, global_funcs_::Sum_Of_Functions)</code></pre><p>At the cost of being less flexible a Sum<em>Of</em>Piecewise_Functions is more efficient than a PiecewiseFunction. Use this if trying to represent a piecewise function that can be decomposed into a sum of lower dimensional piecewise functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/MultivariateFunctions.jl/blob/439c52f985951594f07d67026f0f3a2cc6c4c5f2/src/0_structs_and_generic_reversals.jl#L533-L538">source</a></section></details></article><h2 id="Date-Handling"><a class="docs-heading-anchor" href="#Date-Handling">Date Handling</a><a id="Date-Handling-1"></a><a class="docs-heading-anchor-permalink" href="#Date-Handling" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MultivariateFunctions.years_from_global_base"><a class="docstring-binding" href="#MultivariateFunctions.years_from_global_base"><code>MultivariateFunctions.years_from_global_base</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">years_between(a::Date, b::Date)
years_between(a::Dates.Day, b::Dates.Day)</code></pre><p>Returns the number of years that have elapsed since 1-Jan-2000. For the purposes of this calculation there are 365.2422 days in a year.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/MultivariateFunctions.jl/blob/439c52f985951594f07d67026f0f3a2cc6c4c5f2/src/date_conversions.jl#L19-L25">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MultivariateFunctions.years_between"><a class="docstring-binding" href="#MultivariateFunctions.years_between"><code>MultivariateFunctions.years_between</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">years_between(until::Date, from::Date)
years_between(until::Dates.Day, from::Dates.Day)</code></pre><p>Returns the number of years between two dates. For the purposes of this calculation there are 365.2422 days in a year.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/MultivariateFunctions.jl/blob/439c52f985951594f07d67026f0f3a2cc6c4c5f2/src/date_conversions.jl#L5-L11">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MultivariateFunctions.period_length"><a class="docstring-binding" href="#MultivariateFunctions.period_length"><code>MultivariateFunctions.period_length</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Period length is designed to convert TimePeriod objects to a float in a consistent way to years_from_global_base</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/MultivariateFunctions.jl/blob/439c52f985951594f07d67026f0f3a2cc6c4c5f2/src/date_conversions.jl#L34-L36">source</a></section></details></article><h2 id="Evaluation-and-Inspection"><a class="docs-heading-anchor" href="#Evaluation-and-Inspection">Evaluation and Inspection</a><a id="Evaluation-and-Inspection-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluation-and-Inspection" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="SchumakerSpline.evaluate"><a class="docstring-binding" href="#SchumakerSpline.evaluate"><code>SchumakerSpline.evaluate</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">evaluate(f::MultivariateFunction, coordinates::Dict{Symbol,Float64})
evaluates a function at coordinates.

For univariate functions with a variable name of :default (such as those created by PE_Function&#39;s convenience functions)
evaluation can take place with no dictionary:
evaluate(f::MultivariateFunction, coordinate::Float64)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/MultivariateFunctions.jl/blob/439c52f985951594f07d67026f0f3a2cc6c4c5f2/src/0_structs_and_generic_reversals.jl#L132-L139">source</a></section><section><div><pre><code class="language-julia hljs">evaluate(hess::Hessian, coordinates::Dict{Symbol,Float64})</code></pre><p>This evaluates a Hessian object to create a Hermitian matrix representing the hessian at a point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/MultivariateFunctions.jl/blob/439c52f985951594f07d67026f0f3a2cc6c4c5f2/src/2_calculus.jl#L180-L184">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MultivariateFunctions.underlying_dimensions"><a class="docstring-binding" href="#MultivariateFunctions.underlying_dimensions"><code>MultivariateFunctions.underlying_dimensions</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">underlying_dimensions(f::MultivariateFunction)
Returns a set containing all of the variables upon which f depends.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/MultivariateFunctions.jl/blob/439c52f985951594f07d67026f0f3a2cc6c4c5f2/src/0_structs_and_generic_reversals.jl#L157-L160">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MultivariateFunctions.:≂"><a class="docstring-binding" href="#MultivariateFunctions.:≂"><code>MultivariateFunctions.:≂</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">≂</code></pre><p>This tests whether two structs are close after allowing for numerical tolerance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/MultivariateFunctions.jl/blob/439c52f985951594f07d67026f0f3a2cc6c4c5f2/src/0_structs_and_generic_reversals.jl#L615-L618">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MultivariateFunctions.rebadge"><a class="docstring-binding" href="#MultivariateFunctions.rebadge"><code>MultivariateFunctions.rebadge</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">rebadge(f::PE_Function, mapping::Dict{Symbol,Symbol})
can be used to change the names of the variables in a MultivariateFunction.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/MultivariateFunctions.jl/blob/439c52f985951594f07d67026f0f3a2cc6c4c5f2/src/0_structs_and_generic_reversals.jl#L106-L109">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MultivariateFunctions.change_base"><a class="docstring-binding" href="#MultivariateFunctions.change_base"><code>MultivariateFunctions.change_base</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">change_base(f::PE_Function, new_bases::Dict{Symbol,Float64})</code></pre><p>This function changes the bases in the PE<em>Units of a PE</em>Function. This is useful for getting two PE<em>Functions comformable for simpler multiplication. Often a base change means that an array of PE</em>Functions are needed to represent a function. So an Array{PE_Function,1} is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/MultivariateFunctions.jl/blob/439c52f985951594f07d67026f0f3a2cc6c4c5f2/src/1_algebra.jl#L33-L38">source</a></section></details></article><h2 id="Algebra"><a class="docs-heading-anchor" href="#Algebra">Algebra</a><a id="Algebra-1"></a><a class="docs-heading-anchor-permalink" href="#Algebra" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Base.:+"><a class="docstring-binding" href="#Base.:+"><code>Base.:+</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>+(f::MultivariateFunction,number::Float64)    +(f::MultivariateFunction,number::Int)</p><p>A Multivariate Function can be added to an scalar to from a new MultivariateFunction. This action promotes a    PE<em>Function to a Sum</em>Of_Functions. The type of all other MultivariateFunctions is unchanged.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/MultivariateFunctions.jl/blob/439c52f985951594f07d67026f0f3a2cc6c4c5f2/src/1_algebra.jl#L67-L73">source</a></section><section><div><pre><code class="language-julia hljs">+(f1::MultivariateFunction, f2::MultivariateFunction)
Any two multivariate Functions can be added to form a MultivariateFunction reflecting the sum.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/MultivariateFunctions.jl/blob/439c52f985951594f07d67026f0f3a2cc6c4c5f2/src/1_algebra.jl#L150-L153">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:-"><a class="docstring-binding" href="#Base.:-"><code>Base.:-</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>-(f::MultivariateFunction,number::Float64)    -(f::MultivariateFunction,number::Int)</p><p>A scalar can be subtracted from a Multivariate Function. This action promotes a    PE<em>Function to a Sum</em>Of_Functions. The type of all other MultivariateFunctions is unchanged.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/MultivariateFunctions.jl/blob/439c52f985951594f07d67026f0f3a2cc6c4c5f2/src/1_algebra.jl#L78-L84">source</a></section><section><div><pre><code class="language-julia hljs">-(f1::MultivariateFunction, f2::MultivariateFunction)
Any MultivariateFunction can be subtracted from another to form a MultivariateFunction reflecting the difference.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/MultivariateFunctions.jl/blob/439c52f985951594f07d67026f0f3a2cc6c4c5f2/src/1_algebra.jl#L173-L176">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:*"><a class="docstring-binding" href="#Base.:*"><code>Base.:*</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>*(f::MultivariateFunction,number::Float64)    *(f::MultivariateFunction,number::Int)</p><p>A Multivariate can be multiplied by a scalar. This does not change the type of any MultivariateFunction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/MultivariateFunctions.jl/blob/439c52f985951594f07d67026f0f3a2cc6c4c5f2/src/1_algebra.jl#L88-L93">source</a></section><section><div><pre><code class="language-julia hljs">*(f1::MultivariateFunction, f2::MultivariateFunction)
Any two MultivariateFunctions can be multiplied to form a MultivariateFunction reflecting the product.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/MultivariateFunctions.jl/blob/439c52f985951594f07d67026f0f3a2cc6c4c5f2/src/1_algebra.jl#L199-L202">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:/"><a class="docstring-binding" href="#Base.:/"><code>Base.:/</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>/(f::MultivariateFunction,number::Float64)    /(f::MultivariateFunction,number::Int)</p><p>A Multivariate can be divided by a scalar. This does not change the type of any MultivariateFunction.    Note that the opposite operation cannot be done. While f / 5 is permitted 5 / f is not supported by this package.    It is not possible to divide by a function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/MultivariateFunctions.jl/blob/439c52f985951594f07d67026f0f3a2cc6c4c5f2/src/1_algebra.jl#L97-L104">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:^"><a class="docstring-binding" href="#Base.:^"><code>Base.:^</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>^(f::MultivariateFunction,number::Int)</p><p>A Multivariate can be raised by a positive Integer power. This will generally promote a PE<em>Function to a Sum</em>Of_Functions.    Note that the opposite operation cannot be done. While f ^ 5 is permitted 5 ^ f is not supported by this package.    It is not possible to raise by the power of a function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/MultivariateFunctions.jl/blob/439c52f985951594f07d67026f0f3a2cc6c4c5f2/src/1_algebra.jl#L125-L131">source</a></section></details></article><h2 id="Calculus"><a class="docs-heading-anchor" href="#Calculus">Calculus</a><a id="Calculus-1"></a><a class="docs-heading-anchor-permalink" href="#Calculus" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MultivariateFunctions.derivative"><a class="docstring-binding" href="#MultivariateFunctions.derivative"><code>MultivariateFunctions.derivative</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs"> derivative(f::MultivariateFunction, derivs::Dict{Symbol,Int})</code></pre><p>This generates a function representing the derivative of function f. The derivative is that specified by the derivs dict. So if derivs is Dict{[:x,:y] .=&gt; [1,2]} then there will be one derivative with respect to x and 2 with respect to y.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/MultivariateFunctions.jl/blob/439c52f985951594f07d67026f0f3a2cc6c4c5f2/src/2_calculus.jl#L23-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MultivariateFunctions.all_derivatives"><a class="docstring-binding" href="#MultivariateFunctions.all_derivatives"><code>MultivariateFunctions.all_derivatives</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs"> all_derivatives(f::MultivariateFunction, degree::Int = 2, dimensions::Set{Symbol} = underlying_dimensions(f))</code></pre><p>This generates a dict containing functions representing all of the deriviates of a function up to the order of degree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/MultivariateFunctions.jl/blob/439c52f985951594f07d67026f0f3a2cc6c4c5f2/src/2_calculus.jl#L116-L119">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MultivariateFunctions.integral"><a class="docstring-binding" href="#MultivariateFunctions.integral"><code>MultivariateFunctions.integral</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs"> integral(f::PE_Function, limits::Dict{Symbol,Tuple{Union{Symbol,Float64},Union{Symbol,Float64}}})
 integral(f::Sum_Of_Functions, limits::Dict{Symbol,Tuple{Union{Symbol,Float64},Union{Symbol,Float64}}})</code></pre><p>This gives a function representing the integral of a function, f, with limits in each dimension given by a dict. The dict should contain a tuple for each variable in the function. The left member of the tuple contains the lower limit and the right member the upper limite. Each can be a Float64 or a symbol. If a symbol is input then this will get incorporated as a dimension in the MultivariateFunction created by the integral function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/MultivariateFunctions.jl/blob/439c52f985951594f07d67026f0f3a2cc6c4c5f2/src/2_calculus.jl#L330-L337">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MultivariateFunctions.Hessian"><a class="docstring-binding" href="#MultivariateFunctions.Hessian"><code>MultivariateFunctions.Hessian</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Hessian(f::MultivariateFunction, dimensions::Array{Symbol,1})
Hessian(derivs::Union{Dict{Dict{Symbol,Int},PE_Function},Dict{Dict{Symbol,Int},Sum_Of_Functions},Dict{Dict{Symbol,Int},Piecewise_Function}}, labels_::Array{Symbol,1})</code></pre><p>This represents expressions for constructing a hessian matrix for a function. It can be evaluated to get a Hermitian matrix of the hessian at a particular location.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/MultivariateFunctions.jl/blob/439c52f985951594f07d67026f0f3a2cc6c4c5f2/src/2_calculus.jl#L162-L167">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MultivariateFunctions.jacobian"><a class="docstring-binding" href="#MultivariateFunctions.jacobian"><code>MultivariateFunctions.jacobian</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">jacobian(derivs::Union{Dict{Dict{Symbol,Int},PE_Function},Dict{Dict{Symbol,Int},Sum_Of_Functions},Dict{Dict{Symbol,Int},Piecewise_Function}}, labels::Array{Symbol,1})
jacobian(f::MultivariateFunction, dimensions::Array{Symbol,1})</code></pre><p>This generates an array of MultivariateFunctions representing the derivatives of a function. This array can be evaluated with evaluate.(jacobian, Ref(coordinates))  to give a vector of the derivative values at a point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/MultivariateFunctions.jl/blob/439c52f985951594f07d67026f0f3a2cc6c4c5f2/src/2_calculus.jl#L142-L147">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MultivariateFunctions.uniroot"><a class="docstring-binding" href="#MultivariateFunctions.uniroot"><code>MultivariateFunctions.uniroot</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">uniroot(f::MultivariateFunction, initial_guess::Dict{Symbol,Float64}; step_size::Float64 = 1.0, max_iters::Int = 40, convergence_tol::Float64 = 1e-10, print_reports::Bool = false)</code></pre><p>This takes the analytical jacobian and hessian of a function and uses them to find a nearby root. It finds a root using Newton&#39;s method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/MultivariateFunctions.jl/blob/439c52f985951594f07d67026f0f3a2cc6c4c5f2/src/2_calculus.jl#L243-L247">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MultivariateFunctions.find_local_optima"><a class="docstring-binding" href="#MultivariateFunctions.find_local_optima"><code>MultivariateFunctions.find_local_optima</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">find_local_optima(func::MultivariateFunction, initial_guess::Dict{Symbol,Float64}; step_size::Float64 = 1.0, max_iters::Int = 40, convergence_tol::Float64 = 1e-10, print_reports::Bool = false)</code></pre><p>This takes the analytical jacobian and hessian of a function and uses them to find a nearby optima. The optima it will find are based on Newton&#39;s method. There is no way to specify whether a minimum or a maximum is sought in Newton&#39;s method (at least the pure version of it) and thus this function cannot selectively search for a maximum or minimum. It simply searches for a stationary point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/MultivariateFunctions.jl/blob/439c52f985951594f07d67026f0f3a2cc6c4c5f2/src/2_calculus.jl#L199-L205">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MultivariateFunctions.hypercubes_to_integrate"><a class="docstring-binding" href="#MultivariateFunctions.hypercubes_to_integrate"><code>MultivariateFunctions.hypercubes_to_integrate</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs"> integral(f::Piecewise_Function, limits::Dict{Symbol,Tuple{Float64,Float64}})
 integral(f::Sum_Of_Piecewise_Functions, limits::Dict{Symbol,Tuple{Float64,Float64}})</code></pre><p>This gives a function representing the integral of a function, f, with limits in each dimension given by a dict. The dict should contain a tuple for each variable in the function. The left member of the tuple contains the lower limit and the right member the upper limite. Each must be a Float64 (Support for inputting a symbol is planned but not yet implemented).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/MultivariateFunctions.jl/blob/439c52f985951594f07d67026f0f3a2cc6c4c5f2/src/2_calculus.jl#L385-L391">source</a></section></details></article><h2 id="Interpolation"><a class="docs-heading-anchor" href="#Interpolation">Interpolation</a><a id="Interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#Interpolation" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MultivariateFunctions.create_quadratic_spline"><a class="docstring-binding" href="#MultivariateFunctions.create_quadratic_spline"><code>MultivariateFunctions.create_quadratic_spline</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">create_quadratic_spline(x::Array{Date,1},y::Array{Float64,1} ; gradients::Union{missing,Array{Float64,1}} = missing, extrapolation::Tuple{Schumaker_ExtrapolationSchemes,Schumaker_ExtrapolationSchemes} = (Curve, Curve), left_gradient::Union{Missing,Float64} = missing, right_gradient::Union{Missing,Float64} = missing, dim_name::Symbol = default_symbol)
create_quadratic_spline(x::Array{Int,1},y::Array{Float64,1} ; gradients::Union{missing,Array{Float64,1}} = missing, extrapolation::Tuple{Schumaker_ExtrapolationSchemes,Schumaker_ExtrapolationSchemes} = (Curve, Curve), left_gradient::Union{Missing,Float64} = missing, right_gradient::Union{Missing,Float64} = missing, dim_name::Symbol = default_symbol)
create_quadratic_spline(x::Array{Float64,1},y::Array{Float64,1} ; gradients::Union{missing,Array{Float64,1}} = missing, extrapolation::Tuple{Schumaker_ExtrapolationSchemes,Schumaker_ExtrapolationSchemes} = (Curve, Curve), left_gradient::Union{Missing,Float64} = missing, right_gradient::Union{Missing,Float64} = missing, dim_name::Symbol = default_symbol)
create_quadratic_spline(schum::Schumaker; dim_name::Symbol = default_symbol)</code></pre><p>Create a quadratic spline. The spline is a Schumaker shape-preserving spline which is taken from the SchumakerSpline.jl package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/MultivariateFunctions.jl/blob/439c52f985951594f07d67026f0f3a2cc6c4c5f2/src/3_1D_splines_and_interpolation.jl#L1-L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MultivariateFunctions.create_linear_interpolation"><a class="docstring-binding" href="#MultivariateFunctions.create_linear_interpolation"><code>MultivariateFunctions.create_linear_interpolation</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">create_linear_interpolation(x::Array{Date,1},y::Array{Float64,1}; dim_name::Symbol = default_symbol)
create_linear_interpolation(x::Array{&lt;:DatePeriod,1},y::Array{Float64,1}; dim_name::Symbol = default_symbol)
create_linear_interpolation(x::Array{Float64,1},y::Array{Float64,1}; dim_name::Symbol = default_symbol)</code></pre><p>Create a piecewise linear one-dimensional function which interpolates linearly between datapoints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/MultivariateFunctions.jl/blob/439c52f985951594f07d67026f0f3a2cc6c4c5f2/src/3_1D_splines_and_interpolation.jl#L94-L100">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MultivariateFunctions.create_constant_interpolation_to_left"><a class="docstring-binding" href="#MultivariateFunctions.create_constant_interpolation_to_left"><code>MultivariateFunctions.create_constant_interpolation_to_left</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">create_constant_interpolation_to_left(x::Array{Date,1},y::Array{Float64,1}; dim_name::Symbol = default_symbol)
create_constant_interpolation_to_left(x::Array{&lt;:DatePeriod,1},y::Array{Float64,1}; dim_name::Symbol = default_symbol)
create_constant_interpolation_to_left(x::Array{Float64,1},y::Array{Float64,1}; dim_name::Symbol = default_symbol)</code></pre><p>Create a piecewise constant one-dimensional function which carries values from the right to the left.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/MultivariateFunctions.jl/blob/439c52f985951594f07d67026f0f3a2cc6c4c5f2/src/3_1D_splines_and_interpolation.jl#L70-L76">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MultivariateFunctions.create_constant_interpolation_to_right"><a class="docstring-binding" href="#MultivariateFunctions.create_constant_interpolation_to_right"><code>MultivariateFunctions.create_constant_interpolation_to_right</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">create_constant_interpolation_to_right(x::Array{Date,1},y::Array{Float64,1}; dim_name::Symbol = default_symbol)
create_constant_interpolation_to_right(x::Array{&lt;:DatePeriod,1},y::Array{Float64,1}; dim_name::Symbol = default_symbol)
create_constant_interpolation_to_right(x::Array{Float64,1},y::Array{Float64,1}; dim_name::Symbol = default_symbol)</code></pre><p>Create a piecewise constant one-dimensional function which carries values from the left to the right.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/MultivariateFunctions.jl/blob/439c52f985951594f07d67026f0f3a2cc6c4c5f2/src/3_1D_splines_and_interpolation.jl#L45-L51">source</a></section></details></article><h2 id="Approximation"><a class="docs-heading-anchor" href="#Approximation">Approximation</a><a id="Approximation-1"></a><a class="docs-heading-anchor-permalink" href="#Approximation" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MultivariateFunctions.get_chebyshevs_up_to"><a class="docstring-binding" href="#MultivariateFunctions.get_chebyshevs_up_to"><code>MultivariateFunctions.get_chebyshevs_up_to</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_chebyshevs_up_to(num::Int, first_kind::Bool = true; dim_name::Symbol = default_symbol)
get_chevyshevs_up_to(num::Int, first_kind::Bool = true; dim_name::Symbol = default_symbol)
Output all chebyshev polynomials up to degree num.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/MultivariateFunctions.jl/blob/439c52f985951594f07d67026f0f3a2cc6c4c5f2/src/chebyshevs.jl#L36-L40">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MultivariateFunctions.create_chebyshev_approximation"><a class="docstring-binding" href="#MultivariateFunctions.create_chebyshev_approximation"><code>MultivariateFunctions.create_chebyshev_approximation</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">create_chebyshev_approximation(f::Function, nodes::Int, degree::Int, limits::OrderedDict{Symbol,Tuple{Float64,Float64}}, function_takes_Dict::Bool = false)</code></pre><p>Creates a Sum<em>Of</em>Functions that approximates a function, f, with a set of chebyshevs of a particular degree. The nodes input specifies at how many locations the function is to be evaluated for approximation purposes in each dimension. The limits OrderedDict specifies the domain of where the function is to be approximated.</p><p>If function<em>takes</em>Dict is true then the function will be evaluated by inputting a  Dict{Symbol,Float64}. Otherwise the function will be evaluated with f(values(limits)...) Note that the order of the OrderedDict specifies the order of inputs to the function in this case.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/MultivariateFunctions.jl/blob/439c52f985951594f07d67026f0f3a2cc6c4c5f2/src/4_chebyshev_approximation.jl#L95-L102">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MultivariateFunctions.create_ols_approximation"><a class="docstring-binding" href="#MultivariateFunctions.create_ols_approximation"><code>MultivariateFunctions.create_ols_approximation</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">create_ols_approximation(dd::DataFrame, y::Symbol, model::MultivariateFunction; dropcollinear = true)
create_ols_approximation(dd::DataFrame, y::Symbol, model::Sum_Of_Functions; dropcollinear = true)
create_ols_approximation(dd::DataFrame, y::Symbol, model::Sum_Of_Piecewise_Functions; dropcollinear = true)</code></pre><p>This creates MultivariationFunction from an OLS regression predicting some variable. You input a dataframe and specify what column in that dataframe is to be predicted by inputting a symbol y. You also input the regression model. This is input as a Array{MultivariateFunction,1}. Each function that is input will be multiplied by the ols coefficient and will return a new function with these coefficients incorporated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/MultivariateFunctions.jl/blob/439c52f985951594f07d67026f0f3a2cc6c4c5f2/src/5_ols_regression.jl#L33-L41">source</a></section><section><div><pre><code class="language-julia hljs">create_ols_approximation(y::Array{Float64,1}, x::Array{Float64,1}, degree::Int; intercept::Bool = true, dim_name::Symbol = default_symbol, base_x::Float64 = 0.0)
create_ols_approximation(y::Array{Float64,1}, x::Array{Date,1}, degree::Int; intercept::Bool = true, dim_name::Symbol = default_symbol, base_date::Date = global_base_date)</code></pre><p>This predicts a linear relationship between the y and x arrays and creates a MultivariateFunction containing the approximation function. The degree specifies how many higher order terms of x should be used (for instance degree 2 implies x and x^2 are both used to predict y).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/MultivariateFunctions.jl/blob/439c52f985951594f07d67026f0f3a2cc6c4c5f2/src/5_ols_regression.jl#L56-L62">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MultivariateFunctions.create_saturated_ols_approximation"><a class="docstring-binding" href="#MultivariateFunctions.create_saturated_ols_approximation"><code>MultivariateFunctions.create_saturated_ols_approximation</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">create_saturated_ols_approximation(dd::DataFrame, y::Symbol, x_variables::Array{Symbol,1}, degree::Int; intercept::Bool = true,  bases::Dict{Symbol,Float64} = Dict{Symbol,Float64}(x_variables .=&gt; repeat([0.0],length(x_variables))))</code></pre><p>This creates MultivariateFunction from an OLS regression predicting some variable. You input a dataframe and specify what column in that dataframe is to be predicted by inputting a symbol y. you also put in an array of what x_variables should be used in prediction. A saturated ols model is then calculated up to the specified degree which is returned as a MultivariateFunction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/MultivariateFunctions.jl/blob/439c52f985951594f07d67026f0f3a2cc6c4c5f2/src/5_ols_regression.jl#L2-L6">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MultivariateFunctions.create_mars_spline"><a class="docstring-binding" href="#MultivariateFunctions.create_mars_spline"><code>MultivariateFunctions.create_mars_spline</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">create_mars_spline(dd::DataFrame, y::Symbol, x_variables::Set{Symbol}, MaxM::Int; rel_tol::Float64 = 1e-2)</code></pre><p>This creates a mars spline given a dataframe, response variable and a set of x<em>variables from the dataframe. The relative tolerance is used in a one-dimensional optimisation step to determine what points at which split values to place a max(0,x-split) function in a particular dimension. The default is intentionally set high because precision is generally not the not that important. For small scale data however you might want to decrease it and increase it for large scale data. You might also want to decrease it if spline creation time doesnt matter much. Note that a small rel</em>tol only affects creation time for the spline and not the evaluation time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/MultivariateFunctions.jl/blob/439c52f985951594f07d67026f0f3a2cc6c4c5f2/src/6_HighDimensionalApproximation.jl#L94-L103">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MultivariateFunctions.create_recursive_partitioning"><a class="docstring-binding" href="#MultivariateFunctions.create_recursive_partitioning"><code>MultivariateFunctions.create_recursive_partitioning</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">create_recursive_partitioning(dd::DataFrame, y::Symbol, x_variables::Set{Symbol}, MaxM::Int; rel_tol::Float64 = 1e-10)</code></pre><p>This creates a recusive partitioning approximation. This seperates the space in to a series of hypercubes each of which has a constant value within the hypercube. Each step of the algorithm divides a hypercube along some dimension so that the different parts of the hypercube can recieve a different value. The relative tolerance is used in a one-dimensional optimisation step to determine what points at which split values to place a hypercube in a particular dimension. The default is intentionally set high because it generally doesnt matter that much. For small scale data however you might want to decrease it and increase it for large scale data. You might also want to decrease it if spline creation time doesnt matter much. Note that a small rel_tol only affects creation time for the spline and not the evaluation time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/MultivariateFunctions.jl/blob/439c52f985951594f07d67026f0f3a2cc6c4c5f2/src/6_HighDimensionalApproximation.jl#L55-L66">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MultivariateFunctions.trim_mars_spline"><a class="docstring-binding" href="#MultivariateFunctions.trim_mars_spline"><code>MultivariateFunctions.trim_mars_spline</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>trim<em>mars</em>spline(dd::DataFrame, y::Symbol, model::Sum<em>Of</em>Piecewise<em>Functions;                    maximum</em>RSS::Float64 = -1.0, maximum<em>increase</em>in<em>RSS::Float64 = -1.0, final</em>number<em>of</em>functions::Int = -1)</p><p>This trims a mars spline created in the create<em>mars</em>spline function. This algorithm goes through each piecewise function in the mars spline and deletes the one that contributes least to the fit. A termination criterion must be set. There are three possible termination criterions. The first is the maximum<em>RSS that can be tolerated. If this is set then functions will be deleted until the deletion of an additional function would push RSS over this amount. The second is maximum</em>increase<em>in</em>RSS which will delete functions until a deletion increases RSS by more than this amount. The final is final<em>number</em>of_functions which reduces the number of fucntions to this number.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/MultivariateFunctions.jl/blob/439c52f985951594f07d67026f0f3a2cc6c4c5f2/src/6_HighDimensionalApproximation.jl#L213-L224">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../6_examples_approximation/">« Examples - Approximation</a><a class="docs-footer-nextpage" href="../99_refs/">References »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Monday 9 February 2026 05:56">Monday 9 February 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
